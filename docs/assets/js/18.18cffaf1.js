(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{186:function(e,n,t){"use strict";t.r(n);var s=t(0),r=Object(s.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("div",{staticClass:"content"},[t("h1",{attrs:{id:"构造函数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#构造函数","aria-hidden":"true"}},[e._v("#")]),e._v(" 构造函数")]),e._v(" "),t("h4",{attrs:{id:"一，new的过程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#一，new的过程","aria-hidden":"true"}},[e._v("#")]),e._v(" 一，new的过程")]),e._v(" "),t("p",[e._v("1，声明一个空对象\n2，空对象的__proto__等于构造函数的prototype\n3，构造函数.call(空对象)")]),e._v(" "),t("h4",{attrs:{id:"二，实现一个异步操作"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#二，实现一个异步操作","aria-hidden":"true"}},[e._v("#")]),e._v(" 二，实现一个异步操作")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("  function Person(name){\n            if (this instanceof Person){\n                // 声明一个空的队列\n                this.queues=[];\n                // 将默认的行为放在队列中\n                this.queues.push({\n                    delay:0,\n                    cb:()=>console.log(`This is ${name}`)\n                })\n                // 异步调用run方法执行队列\n                setTimeout(()=>{\n                    this.run()\n                })\n            }else{\n                // 无new实例化\n                return new Person(name);\n            }\n        }\n        // 执行队列\n        Person.prototype.run=async function(){\n            for(let i =0;i<this.queues.length;i++){\n                let delay = this.queues[i].delay,\n                    cb = this.queues[i].cb\n                    if(delay){\n                     \n                      await this.toPromise(delay,cb)\n                    }else{\n                       await  cb()\n                    }\n            }\n        }\n        // //返回一个Promise,阻塞执行\n        Person.prototype.toPromise= function(delay,cb){\n            // 把一个有延迟的函数转为promise,延迟时间为状态改为resolve的时间\n            return new Promise((resolve,reject)=>{\n                setTimeout(()=>{\n                    cb()\n                    resolve()\n                },delay)\n            })\n        }\n        Person.prototype.sleep=function(delay){\n            this.queues.push({\n                delay,\n                cb:()=>console.log(`sleep after ${delay}`)\n            })\n            return this\n        }\n        Person.prototype.eat=function(food){\n            this.queues.push({\n                delay:0,\n                cb:()=>console.log(`eat ${food}`)\n            })\n            return this\n        }\n        Person.prototype.sleepFirst=function(delay){\n            this.queues.unshift({\n                delay,\n                cb:()=>console.log(`sleep befor ${delay}`)\n            })\n            return this\n        }\n      Person('li').sleep(3000).eat('dener').sleepFirst('5000')\n\n")])])])])}],!1,null,null,null);n.default=r.exports}}]);